### Clear Diagnosis

1.  **`TypeError: send_reply() got an unexpected keyword argument 'message'`**: The call to `send_reply()` in `bizzauto_api/routers/api/meta_whatsapp.py` is using `message=reply`, but the `send_reply()` function in `bizzauto_api/whatsapp_utils.py` expects the argument `data=reply`.
2.  **`create_whatsapp_log() missing 1 required positional argument: 'user_id'`**: The `PydanticWhatsappLog` model in `bizzauto_api/models.py` is missing the `user_id` field, which is required when creating the corresponding SQLAlchemy `WhatsappLog` object.
3.  **`ERROR inside run_whatsapp_agent: 404 models/gemini-pro is not found for API version v1beta`**: The `run_whatsapp_agent` in `bizzauto_api/whatsapp_agent.py` is attempting to use a Gemini model (`gemini-1.5-flash`) that is either incorrect or unavailable for the specified API version; the error message suggests `gemini-pro`.
4.  **WhatsApp message processing warnings/Background task errors**: These are largely secondary to the above fundamental errors. Improved logging will help diagnose any remaining issues.

---

### Code Fixes and Rationale

#### File: `bizzauto_api/whatsapp_utils.py`

**Rationale**: The `send_reply` function's signature was already correct, expecting `data`. No changes are needed here, but it's included for completeness.

```python
# bizzauto_api/whatsapp_utils.py
import re
import httpx
import os
from typing import Optional, Dict, Any

# =================================
# 1. PHONE NUMBER SANITIZATION (CRITICAL)
# =================================
def sanitize_phone_number(phone: str) -> str:
    """
    Removes +, spaces, dashes, and parentheses.
    Example: "+92 342 0024683" -> "923420024683"
    """
    if not phone:
        return ""
    return re.sub(r'\D', '', phone)

# =================================
# 2. SEND AUTO REPLY (WHATSAPP CLOUD API)
# =================================
async def send_reply(to: str, data: Any) -> Optional[Dict[str, Any]]:
    """
    Sends a message using the WhatsApp Cloud API.
    Can be a simple text message (if data is a string) or a complex one like a template (if data is a dict).
    """
    access_token = os.environ.get("WHATSAPP_TOKEN")
    phone_number_id = os.environ.get("PHONE_NUMBER_ID")
    api_version = "v19.0"

    if not access_token or not phone_number_id:
        print("Error: WhatsApp environment variables not set.")
        return None

    clean_to = sanitize_phone_number(to)

    url = f"https://graph.facebook.com/{api_version}/{phone_number_id}/messages"
    
    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json",
    }
    
    payload = {
        "messaging_product": "whatsapp",
        "to": clean_to,
    }

    if isinstance(data, str):
        payload["type"] = "text"
        payload["text"] = {"body": data}
    elif isinstance(data, dict):
        payload.update(data)
    else:
        print("Error: Invalid data type for send_reply. Must be str or dict.")
        return None

    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(url, headers=headers, json=payload, timeout=10.0)
            response.raise_for_status()
            response_json = response.json()
            print(f"[send_reply] Success to {clean_to}")
            print(f"[Meta Response]: {response_json}")
            return response_json
        except httpx.HTTPStatusError as e:
            print(f"[send_reply] FAILED: {e.response.status_code}")
            print(f"[Body]: {e.response.text}")
            return e.response.json()
        except Exception as e:
            print(f"[send_reply] Error: {e}")
            return None
```

#### File: `bizzauto_api/routers/api/meta_whatsapp.py`

**Rationale**:
*   **`send_result = await send_reply(to=sender_phone, data=reply)`**: Corrected the keyword argument from `message` to `data` to match the `send_reply` function's signature, resolving the `TypeError`.
*   **Improved Error Logging**: Added `traceback.print_exc()` to print the full stack trace for exceptions, providing more context for debugging.

**Patch Style Fix for line 93 (from your traceback):**
```diff
---
a/bizzauto_api/routers/api/meta_whatsapp.py
+++ b/bizzauto_api/routers/api/meta_whatsapp.py
@@ -90,7 +90,7 @@
                             if not reply:
                                 continue
 
-                            send_result = await send_reply(to=sender_phone, message=reply)
+                            send_result = await send_reply(to=sender_phone, data=reply)
 
                             whatsapp_message_id_for_log = None
                             if send_result and "messages" in send_result and len(send_result["messages"]) > 0:
```

**Updated `process_whatsapp_message()` function (complete):**
```python
# bizzauto_api/routers/api/meta_whatsapp.py
import os
import tempfile
import asyncio
import requests
import json
import traceback
from fastapi import APIRouter, HTTPException, Request, Depends, Response, status
from sqlalchemy.orm import Session
from database import SessionLocal, get_db
from crud import create_whatsapp_log, get_companies, get_whatsapp_logs, update_whatsapp_log, get_whatsapp_log_by_whatsapp_message_id, create_scheduled_whatsapp_message
from models import WhatsappLog as PydanticWhatsappLog
from models import ScheduledWhatsappMessage as PydanticScheduledWhatsappMessage
from sql_models import User
from ocr_tasks import process_invoice_image_gcp
from whatsapp_utils import send_reply
from whatsapp_agent import run_whatsapp_agent
from pydantic import BaseModel
from typing import Any
from datetime import datetime
from dependencies import get_current_user

router = APIRouter()

# --- Environment Variables ---
ACCESS_TOKEN = os.environ.get("WHATSAPP_TOKEN")
PHONE_NUMBER_ID = os.environ.get("PHONE_NUMBER_ID")
VERIFY_TOKEN = os.environ.get("WHATSAPP_VERIFY_TOKEN")
API_VERSION = "v19.0"

# -----------------------------
# Background processing
# -----------------------------
async def process_whatsapp_message(entry_data: dict):
    print("\n" + "=" * 60)
    print("üöÄ BACKGROUND TASK STARTED")
    print("=" * 60)
    
    try:
        # Log the entire payload
        print(f"üìã Entry data keys: {entry_data.keys()}")
        
        for entry in entry_data.get("entry", []):
            for change in entry.get("changes", []):
                value = change.get("value", {})
                
                if "messages" in value:
                    for message in value.get("messages", []):
                        message_type = message.get("type")
                        sender_phone = message.get("from")
                        message_id = message.get("id")
                        
                        if message_type == "text":
                            incoming_text = message.get("text", {}).get("body", "").strip()
                            
                            if not incoming_text:
                                continue

                            # --- 1. Look up user context & Log INCOMING (Short DB Session) ---
                            user_id_for_log = None
                            company_id_for_log = None
                            
                            db = SessionLocal()
                            try:
                                from sql_models import Client
                                from whatsapp_utils import sanitize_phone_number
                                
                                sanitized_phone = sanitize_phone_number(sender_phone)
                                client = db.query(Client).filter(Client.phone == sanitized_phone).first()

                                if not client:
                                    print(f"‚ö†Ô∏è  No client found for phone number: {sender_phone}. Ignoring message.")
                                    continue

                                user_id_for_log = client.user_id
                                company_id_for_log = client.company_id
                                
                                if not user_id_for_log or not company_id_for_log:
                                    print(f"‚ö†Ô∏è  Client {client.id} is missing user_id or company_id. Ignoring message.")
                                    continue
                                    
                                print(f"‚úÖ Found context: User ID {user_id_for_log}, Company ID {company_id_for_log}")

                                # Log INCOMING Message
                                try:
                                    incoming_log = PydanticWhatsappLog(
                                        company_id=company_id_for_log,
                                        user_id=user_id_for_log,
                                        message_type="text",
                                        whatsapp_message_id=message_id,
                                        phone=sender_phone,
                                        message=incoming_text,
                                        status="received"
                                    )
                                    create_whatsapp_log(db, incoming_log, user_id=user_id_for_log)
                                except Exception as e:
                                    print(f"‚ùå Failed to log incoming message: {e}")
                                    traceback.print_exc() # Add full traceback for detailed debugging
                            finally:
                                db.close()

                            if not user_id_for_log:
                                continue
                                
                            # --- 3. Run Agent (No DB Connection Held) ---
                            reply = await run_whatsapp_agent(incoming_text, sender_phone)
                            
                            if not reply:
                                continue

                            # --- 4. Send Reply (No DB Connection Held) ---
                            send_result = await send_reply(to=sender_phone, data=reply) # FIX APPLIED HERE

                            whatsapp_message_id_for_log = None
                            if send_result and "messages" in send_result and len(send_result["messages"]) > 0:
                                whatsapp_message_id_for_log = send_result["messages"][0].get("id")

                            # --- 5. Log OUTGOING Message (Short DB Session) ---
                            db = SessionLocal()
                            try:
                                new_log = PydanticWhatsappLog(
                                    company_id=company_id_for_log,
                                    user_id=user_id_for_log,
                                    message_type="text",
                                    whatsapp_message_id=whatsapp_message_id_for_log,
                                    phone=sender_phone,
                                    message=reply,
                                    status="sent"
                                )
                                create_whatsapp_log(db, new_log, user_id=user_id_for_log)
                            except Exception as e:
                                print(f"‚ùå Failed to log outgoing message: {e}")
                                traceback.print_exc() # Add full traceback for detailed debugging
                            finally:
                                db.close()

    except Exception as e:
        print(f"Error in process_whatsapp_message: {e}") # More specific error message
        traceback.print_exc()
    
    print("‚úÖ BACKGROUND TASK FINISHED")

# -----------------------------
# Webhook verification
# -----------------------------
@router.get("/webhook")
def verify_webhook(request: Request):
    params = request.query_params
    mode = params.get("hub.mode")
    token = params.get("hub.verify_token")
    challenge = params.get("hub.challenge")
    
    if mode == "subscribe" and token == VERIFY_TOKEN:
        return int(challenge)
    else:
        raise HTTPException(status_code=403, detail="Webhook verification failed.")

# -----------------------------
# Send Message Endpoint
# -----------------------------
class SendMessageRequest(BaseModel):
    to: str
    message_data: Any

@router.post("/send-meta-whatsapp")
async def send_meta_whatsapp_message(
    request: SendMessageRequest, 
    response: Response, 
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    try:
        # 1. Send Message via Meta API
        api_response = await send_reply(to=request.to, data=request.message_data)
        
        if api_response and "messages" in api_response:
            # 2. Save to Database (so it shows in the table)
            try:
                message_body = request.message_data.get("text", {}).get("body", "") if isinstance(request.message_data, dict) else str(request.message_data)
                
                new_message = PydanticScheduledWhatsappMessage(
                    company_id=user.company_id,
                    phone=request.to,
                    message=message_body,
                    scheduled_at=datetime.utcnow(),
                    status='sent'
                )
                create_scheduled_whatsapp_message(db, new_message, user.id)
                print(f"‚úÖ Immediate message saved to DB for {request.to}")
            except Exception as db_e:
                print(f"‚ö†Ô∏è Failed to save immediate message to DB: {db_e}")
                traceback.print_exc() # Add full traceback
            return {"success": True}
        else:
            response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
            print(f"‚ùå Failed to send message via Meta API: {api_response}") # Log API response
            return {"error": "Failed to send message"}
    except Exception as e:
        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
        print(f"‚ùå Error in send_meta_whatsapp_message: {e}") # Log actual error
        traceback.print_exc() # Add full traceback
        return {"error": str(e)}


# -----------------------------
# Webhook to receive messages
# -----------------------------
@router.post("/webhook")
async def receive_webhook(request: Request):
    print("üîî POST /webhook received a request")
    try:
        data = await request.json()
        print(f"üì¶ Webhook Payload: {json.dumps(data, indent=2)}")
        asyncio.create_task(process_whatsapp_message(data))
        return {"status": "received"}
    except Exception as e:
        print(f"‚ùå Error in POST /webhook: {e}")
        traceback.print_exc() # Add full traceback
        return {"status": "error", "message": str(e)}
    
@router.get("/test")
async def test_endpoint():
    return {
        "status": "working",
        "token_set": bool(ACCESS_TOKEN),
        "phone_id_set": bool(PHONE_NUMBER_ID),
        "verify_token_set": bool(VERIFY_TOKEN)
    }
```

#### File: `bizzauto_api/models.py`

**Rationale**: Added `user_id: UUID` to the `WhatsappLog` Pydantic model. This ensures that the `user_id` is correctly carried through the Pydantic model to the SQLAlchemy model, resolving the "missing `user_id`" error.

**Patch Style Fix for `WhatsappLog` model:**
```diff
---
a/bizzauto_api/models.py
+++ b/bizzauto_api/models.py
@@ -148,6 +148,7 @@
 class WhatsappLog(BaseModel):
     id: Optional[UUID] = None
     company_id: UUID
+    user_id: UUID  # Added this line
     message_type: Optional[str] = None
     whatsapp_message_id: Optional[str] = None
     phone: Optional[str] = None
```

**Updated `WhatsappLog` model (complete):**
```python
# bizzauto_api/models.py
from pydantic import BaseModel, Json, ConfigDict, field_serializer, Field
from typing import Optional, List, Any
from uuid import UUID
from datetime import datetime, date
import json

class Company(BaseModel):
    id: Optional[UUID] = None
    name: str
    email: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)

class Client(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    name: str
    phone: Optional[str] = None
    email: Optional[str] = None
    address: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)

class User(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    full_name: str
    email: str
    password_hash: Optional[str] = None
    role: str
    business_name: Optional[str] = None
    location: Optional[str] = None
    contact_number: Optional[str] = None
    status: Optional[str] = 'active'

    model_config = ConfigDict(from_attributes=True)

class Supplier(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    name: str
    phone: Optional[str] = None
    email: Optional[str] = None
    address: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)

class Product(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    name: str
    sku: Optional[str] = None
    category: Optional[str] = None
    purchase_price: float = 0
    sale_price: float = 0
    stock_quantity: int = 0
    low_stock_alert: Optional[int] = 5
    unit: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)

class InvoiceItem(BaseModel):
    id: Optional[UUID] = None
    invoice_id: Optional[UUID] = None # Optional for creation
    product_id: UUID
    quantity: int = 1
    price: float = 0
    total: float = 0

    model_config = ConfigDict(from_attributes=True)

class InvoiceItemCreate(BaseModel):
    product_id: UUID
    quantity: int = 1
    price: float = 0
    total: float = 0

class Invoice(BaseModel):
    id: Optional[UUID] = None
    company_id: Optional[UUID] = None # Optional for creation
    client_id: Optional[UUID] = None
    invoice_date: date = date.today()
    total_amount: float = 0
    payment_status: Optional[str] = 'unpaid'
    notes: Optional[str] = None
    items: List[InvoiceItem] = [] # For response

    model_config = ConfigDict(from_attributes=True)

class InvoiceCreate(BaseModel):
    client_id: UUID
    invoice_date: date
    total_amount: float
    payment_status: Optional[str] = 'unpaid'
    notes: Optional[str] = None
    items: List[InvoiceItemCreate] = []


class Purchase(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    supplier_id: Optional[UUID] = None
    purchase_date: date = date.today()
    total_amount: float = 0
    notes: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)

class PurchaseItem(BaseModel):
    id: Optional[UUID] = None
    purchase_id: UUID
    product_id: UUID
    quantity: int = 1
    price: float = 0
    total: float = 0

    model_config = ConfigDict(from_attributes=True)

class Expense(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    title: str
    category: Optional[str] = None
    amount: float = 0
    expense_date: date = date.today()
    notes: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)

class Lead(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    name: str
    phone: Optional[str] = None
    email: Optional[str] = None
    status: Optional[str] = 'new'

    model_config = ConfigDict(from_attributes=True)

class WhatsappLog(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    user_id: UUID  # FIX APPLIED HERE
    message_type: Optional[str] = None
    whatsapp_message_id: Optional[str] = None
    phone: Optional[str] = None
    message: Optional[str] = None
    status: Optional[str] = 'sent'

    model_config = ConfigDict(from_attributes=True)

class ScheduledWhatsappMessage(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    phone: str
    message: str
    scheduled_at: datetime
    status: Optional[str] = 'pending'

    model_config = ConfigDict(from_attributes=True)

class ScheduledWhatsappMessageCreate(BaseModel):
    phone: str
    message: str
    scheduled_at: Optional[datetime] = None

    model_config = ConfigDict(populate_by_name=True)

class UploadedDoc(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    file_name: str
    file_url: str

    model_config = ConfigDict(from_attributes=True)

class Account(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    name: str
    type: str
    balance: float = 0

    model_config = ConfigDict(from_attributes=True)

class JournalEntry(BaseModel):
    id: Optional[UUID] = None
    company_id: UUID
    account_id: UUID
    invoice_id: Optional[UUID] = None
    purchase_id: Optional[UUID] = None
    expense_id: Optional[UUID] = None
    date: date
    debit: float = 0
    credit: float = 0

    model_config = ConfigDict(from_attributes=True)

class ExpenseReport(BaseModel):
    category: str
    sum: float

class Setting(BaseModel):
    id: Optional[UUID] = None
    user_id: UUID
    key: str
    value: Any

    model_config = ConfigDict(from_attributes=True)

    @field_serializer('value')
    def serialize_value(self, value: any, _info):
        if isinstance(value, (dict, list)):
            return json.dumps(value)
        return value
```

#### File: `bizzauto_api/whatsapp_agent.py`

**Rationale**:
*   **`model_name='gemini-pro'`**: Changed the model name to `gemini-pro` to resolve the 404 error, as suggested by the traceback. This is a robust and generally available Gemini model.
*   **Asynchronous Model Call**: The existing use of `asyncio.to_thread(chat.send_message, message)` correctly handles the potentially blocking `chat.send_message` call, preventing it from blocking the FastAPI event loop.

**Patch Style Fix for model initialization:**
```diff
---
a/bizzauto_api/whatsapp_agent.py
+++ b/bizzauto_api/whatsapp_agent.py
@@ -53,7 +53,7 @@
 # Initialize Model
 # NOTE: If 'gemini-1.5-flash' still gives 404 after pip install, change to 'gemini-pro'
 model = genai.GenerativeModel(
-    model_name='gemini-1.5-flash', 
+    model_name='gemini-pro', 
     system_instruction=system_instructions,
     tools=tools_list
 )
```

**Updated `run_whatsapp_agent()` (complete):**
```python
# bizzauto_api/whatsapp_agent.py
import google.generativeai as genai
import os
import asyncio
from database import SessionLocal
import crud
from uuid import UUID
import json
import traceback # Import traceback for detailed error logging

# ============================ 
# 1. Product Lookup Tool
# ============================ 
def get_product_details(
    product_name: str | None = None,
    product_id: int | None = None
) -> dict:
    """
    Use this function to get the details of a product, such as its price and availability.
    """

    db = SessionLocal()
    try:
        if product_id:
            # Ensure product_id is correctly converted if coming from a non-UUID source
            try:
                product = crud.get_product(db, product_id=UUID(str(product_id)))
            except ValueError:
                return {"error": "Invalid product_id format"}
        elif product_name:
            product = crud.get_product_by_name(db, name=product_name)
        else:
            return {"error": "Provide product_name or product_id"}

        if not product:
            return {"error": "Product not found"}

        return {
            "name": product.name,
            "sku": product.sku,
            "category": product.category,
            "purchase_price": float(product.purchase_price),
            "sale_price": float(product.sale_price),
            "stock_quantity": product.stock_quantity,
            "low_stock_alert": product.low_stock_alert,
            "unit": product.unit,
        }

    except Exception as e:
        print(f"ERROR in get_product_details: {e}")
        traceback.print_exc() # Add full traceback
        return {"error": f"Error fetching product: {str(e)}"}

    finally:
        db.close()

# ============================ 
# Configure Generative Model
# ============================ 
api_key = os.environ.get("GEMINI_API_KEY")
genai.configure(api_key=api_key)

# System instructions
system_instructions = """
You are a helpful and passive assistant for BizzAuto, a company that sells all kinds of wholesale and retailer products.
Your ONLY job is to answer direct questions from users.
- DO NOT initiate conversations or send proactive messages.
- If a user asks about a specific product, ALWAYS use the `get_product_details` tool to check for it.
- If the tool finds the product and it is in stock (stock_quantity > 0), reply with "Yes, we have [product name]! The price is [sale_price]."
- If the tool finds the product but it is out of stock (stock_quantity <= 0), reply with "Sorry, [product name] is currently out of stock."
- For any other questions, provide a short and helpful answer.
- Keep all responses concise and to the point.
"""

tools_list = [get_product_details]

# Initialize Model
# NOTE: If 'gemini-1.5-flash' still gives 404 after pip install, change to 'gemini-pro'
model = genai.GenerativeModel(
    model_name='gemini-pro', # FIX APPLIED HERE
    system_instruction=system_instructions,
    tools=tools_list
)

chat_sessions = {}

# ============================ 
# Runner Wrapper (Async Fixed)
# ============================ 
async def run_whatsapp_agent(message: str, phone_number: str) -> str:
    """
    Async wrapper that handles the chat logic
    """
    try:
        # 1. Create Chat Session if not exists
        if phone_number not in chat_sessions:
            chat_sessions[phone_number] = model.start_chat(
                enable_automatic_function_calling=True
            )
        
        chat = chat_sessions[phone_number]

        # 2. Run the blocking Gemini call in a thread to prevent blocking FastAPI
        # This fixes the "await" error while keeping the server responsive
        response = await asyncio.to_thread(chat.send_message, message)
        
        # Ensure that response.text is always a string, even if empty or None
        return response.text if response and response.text is not None else ""

    except Exception as e:
        # Log the actual error for debugging
        print(f"ERROR inside run_whatsapp_agent for phone {phone_number}: {e}")
        traceback.print_exc() # Add full traceback
        
        # If the model name is wrong, catch it here
        if "404" in str(e) and "models/" in str(e):
            return "System Error: AI Model version mismatch. Please contact admin."
            
        return "Sorry, I'm having trouble connecting to the system right now. üîß"
```

#### Code to Initialize and Call Gemini Model (Example)

**Required pip package(s):**
```bash
pip install google-generativeai
```

**Environment Variable Configuration (`.env`):**
```
GEMINI_API_KEY="YOUR_GEMINI_API_KEY"
```

**Exact model_name string to use:** `'gemini-pro'`

**Example Code (from `whatsapp_agent.py` after fixes):**
```python
import google.generativeai as genai
import os
import asyncio

# Configure API key
api_key = os.environ.get("GEMINI_API_KEY")
genai.configure(api_key=api_key)

# Initialize Model with system instructions and tools
model = genai.GenerativeModel(
    model_name='gemini-pro', 
    system_instruction="You are a helpful assistant.",
    tools=[] # Your list of tools
)

# To start a chat session
chat = model.start_chat(enable_automatic_function_calling=True)

# To send a message asynchronously using asyncio.to_thread
async def send_message_to_gemini(user_message: str):
    response = await asyncio.to_thread(chat.send_message, user_message)
    return response.text

# Example usage within an async function
async def main():
    reply = await send_message_to_gemini("Hello, how are you?")
    print(reply)

# If running directly (for testing outside FastAPI)
# import asyncio
# asyncio.run(main())
```
**Rationale**: This snippet demonstrates the minimal setup for initializing and interacting with the Gemini `gemini-pro` model, including the necessary API key configuration and asynchronous handling.

---

### Validation Checklist and Test Plan

To confirm all fixes are working as expected, follow these steps locally:

1.  **Redeploy your application**: Ensure all the code changes provided above are applied to your project and redeploy your FastAPI application. This is crucial as the errors indicate your deployment is running outdated code.
    *   **Action**: Update local files with the provided code, then restart your FastAPI server (and any related Docker containers if applicable).
2.  **Test WhatsApp message processing and AI response**:
    *   **Action**: Send a message to your WhatsApp number connected to the webhook (e.g., "What products do you have?").
    *   **Expected Result**:
        *   Your application logs should show:
            *   `‚úÖ Found context: User ID ..., Company ID ...`
            *   No `‚ùå Failed to log incoming message: create_whatsapp_log() missing 1 required positional argument: 'user_id'` error.
            *   No `ERROR inside run_whatsapp_agent: 404 models/gemini-pro is not found...` error.
            *   No `TypeError: send_reply() got an unexpected keyword argument 'message'` error.
            *   `[send_reply] Success to ...`
            *   A relevant AI-generated reply should be received on WhatsApp.
3.  **Test Product Lookup Tool**:
    *   **Action**: Send a message like "Do you have product XYZ?" (replace XYZ with a product from your database).
    *   **Expected Result**:
        *   The AI should correctly use the `get_product_details` tool.
        *   If the product exists and is in stock, the reply should be "Yes, we have [product name]! The price is [sale_price]."
        *   If out of stock: "Sorry, [product name] is currently out of stock."
        *   If not found: "Sorry, I couldn't find a product by that name."
        *   All backend logs should remain clean (no errors related to `crud` or `gemini`).

---

I have addressed all your requests. Please apply these fixes carefully and ensure a full redeployment of your application.